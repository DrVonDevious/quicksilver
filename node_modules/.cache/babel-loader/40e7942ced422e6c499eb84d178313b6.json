{"ast":null,"code":"module.exports = compile;\n\nvar BaseFuncs = require(\"boolbase\"),\n    trueFunc = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc;\n/*\n\treturns a function that checks if an elements index matches the given rule\n\thighly optimized to return the fastest solution\n*/\n\n\nfunction compile(parsed) {\n  var a = parsed[0],\n      b = parsed[1] - 1; //when b <= 0, a*n won't be possible for any matches when a < 0\n  //besides, the specification says that no element is matched when a and b are 0\n\n  if (b < 0 && a <= 0) return falseFunc; //when a is in the range -1..1, it matches any element (so only b is checked)\n\n  if (a === -1) return function (pos) {\n    return pos <= b;\n  };\n  if (a === 0) return function (pos) {\n    return pos === b;\n  }; //when b <= 0 and a === 1, they match any element\n\n  if (a === 1) return b < 0 ? trueFunc : function (pos) {\n    return pos >= b;\n  }; //when a > 0, modulo can be used to check if there is a match\n\n  var bMod = b % a;\n  if (bMod < 0) bMod += a;\n\n  if (a > 1) {\n    return function (pos) {\n      return pos >= b && pos % a === bMod;\n    };\n  }\n\n  a *= -1; //make `a` positive\n\n  return function (pos) {\n    return pos <= b && pos % a === bMod;\n  };\n}","map":{"version":3,"sources":["/Users/william/Dev/quicksilver/src/client/node_modules/nth-check/compile.js"],"names":["module","exports","compile","BaseFuncs","require","trueFunc","falseFunc","parsed","a","b","pos","bMod"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,IAAIC,SAAS,GAAGC,OAAO,CAAC,UAAD,CAAvB;AAAA,IACIC,QAAQ,GAAIF,SAAS,CAACE,QAD1B;AAAA,IAEIC,SAAS,GAAGH,SAAS,CAACG,SAF1B;AAIA;;;;;;AAIA,SAASJ,OAAT,CAAiBK,MAAjB,EAAwB;AACvB,MAAIC,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAd;AAAA,MACIE,CAAC,GAAGF,MAAM,CAAC,CAAD,CAAN,GAAY,CADpB,CADuB,CAIvB;AACA;;AACA,MAAGE,CAAC,GAAG,CAAJ,IAASD,CAAC,IAAI,CAAjB,EAAoB,OAAOF,SAAP,CANG,CAQvB;;AACA,MAAGE,CAAC,KAAI,CAAC,CAAT,EAAY,OAAO,UAASE,GAAT,EAAa;AAAE,WAAOA,GAAG,IAAID,CAAd;AAAkB,GAAxC;AACZ,MAAGD,CAAC,KAAK,CAAT,EAAY,OAAO,UAASE,GAAT,EAAa;AAAE,WAAOA,GAAG,KAAKD,CAAf;AAAmB,GAAzC,CAVW,CAWvB;;AACA,MAAGD,CAAC,KAAK,CAAT,EAAY,OAAOC,CAAC,GAAG,CAAJ,GAAQJ,QAAR,GAAmB,UAASK,GAAT,EAAa;AAAE,WAAOA,GAAG,IAAID,CAAd;AAAkB,GAA3D,CAZW,CAcvB;;AACA,MAAIE,IAAI,GAAGF,CAAC,GAAGD,CAAf;AACA,MAAGG,IAAI,GAAG,CAAV,EAAaA,IAAI,IAAIH,CAAR;;AAEb,MAAGA,CAAC,GAAG,CAAP,EAAS;AACR,WAAO,UAASE,GAAT,EAAa;AACnB,aAAOA,GAAG,IAAID,CAAP,IAAYC,GAAG,GAAGF,CAAN,KAAYG,IAA/B;AACA,KAFD;AAGA;;AAEDH,EAAAA,CAAC,IAAI,CAAC,CAAN,CAxBuB,CAwBd;;AAET,SAAO,UAASE,GAAT,EAAa;AACnB,WAAOA,GAAG,IAAID,CAAP,IAAYC,GAAG,GAAGF,CAAN,KAAYG,IAA/B;AACA,GAFD;AAGA","sourcesContent":["module.exports = compile;\n\nvar BaseFuncs = require(\"boolbase\"),\n    trueFunc  = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc;\n\n/*\n\treturns a function that checks if an elements index matches the given rule\n\thighly optimized to return the fastest solution\n*/\nfunction compile(parsed){\n\tvar a = parsed[0],\n\t    b = parsed[1] - 1;\n\n\t//when b <= 0, a*n won't be possible for any matches when a < 0\n\t//besides, the specification says that no element is matched when a and b are 0\n\tif(b < 0 && a <= 0) return falseFunc;\n\n\t//when a is in the range -1..1, it matches any element (so only b is checked)\n\tif(a ===-1) return function(pos){ return pos <= b; };\n\tif(a === 0) return function(pos){ return pos === b; };\n\t//when b <= 0 and a === 1, they match any element\n\tif(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };\n\n\t//when a > 0, modulo can be used to check if there is a match\n\tvar bMod = b % a;\n\tif(bMod < 0) bMod += a;\n\n\tif(a > 1){\n\t\treturn function(pos){\n\t\t\treturn pos >= b && pos % a === bMod;\n\t\t};\n\t}\n\n\ta *= -1; //make `a` positive\n\n\treturn function(pos){\n\t\treturn pos <= b && pos % a === bMod;\n\t};\n}"]},"metadata":{},"sourceType":"script"}