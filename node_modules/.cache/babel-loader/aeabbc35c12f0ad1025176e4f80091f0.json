{"ast":null,"code":"// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function (nodes) {\n  var idx = nodes.length,\n      node,\n      ancestor,\n      replace; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx > -1) {\n    node = ancestor = nodes[idx]; // Temporarily remove the node under consideration\n\n    nodes[idx] = null;\n    replace = true;\n\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n\n      ancestor = ancestor.parent;\n    } // If the node has been found to be unique, re-insert it.\n\n\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n\n  return nodes;\n};","map":{"version":3,"sources":["/Users/william/Dev/quicksilver/src/client/node_modules/cheerio/node_modules/domutils/lib/helpers.js"],"names":["exports","removeSubsets","nodes","idx","length","node","ancestor","replace","indexOf","splice","parent"],"mappings":"AAAA;AACA;AACAA,OAAO,CAACC,aAAR,GAAwB,UAASC,KAAT,EAAgB;AACvC,MAAIC,GAAG,GAAGD,KAAK,CAACE,MAAhB;AAAA,MAAwBC,IAAxB;AAAA,MAA8BC,QAA9B;AAAA,MAAwCC,OAAxC,CADuC,CAGvC;AACA;;AACA,SAAO,EAAEJ,GAAF,GAAQ,CAAC,CAAhB,EAAmB;AAClBE,IAAAA,IAAI,GAAGC,QAAQ,GAAGJ,KAAK,CAACC,GAAD,CAAvB,CADkB,CAGlB;;AACAD,IAAAA,KAAK,CAACC,GAAD,CAAL,GAAa,IAAb;AACAI,IAAAA,OAAO,GAAG,IAAV;;AAEA,WAAOD,QAAP,EAAiB;AAChB,UAAIJ,KAAK,CAACM,OAAN,CAAcF,QAAd,IAA0B,CAAC,CAA/B,EAAkC;AACjCC,QAAAA,OAAO,GAAG,KAAV;AACAL,QAAAA,KAAK,CAACO,MAAN,CAAaN,GAAb,EAAkB,CAAlB;AACA;AACA;;AACDG,MAAAA,QAAQ,GAAGA,QAAQ,CAACI,MAApB;AACA,KAdiB,CAgBlB;;;AACA,QAAIH,OAAJ,EAAa;AACZL,MAAAA,KAAK,CAACC,GAAD,CAAL,GAAaE,IAAb;AACA;AACD;;AAED,SAAOH,KAAP;AACA,CA5BD","sourcesContent":["// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n"]},"metadata":{},"sourceType":"script"}