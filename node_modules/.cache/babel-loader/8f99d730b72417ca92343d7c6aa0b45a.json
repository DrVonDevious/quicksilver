{"ast":null,"code":"/*\n\tcompiles a selector to an executable function\n*/\nmodule.exports = compile;\nmodule.exports.compileUnsafe = compileUnsafe;\n\nvar parse = require(\"css-what\"),\n    DomUtils = require(\"domutils\"),\n    isTag = DomUtils.isTag,\n    Rules = require(\"./general.js\"),\n    sortRules = require(\"./sort.js\"),\n    BaseFuncs = require(\"boolbase\"),\n    trueFunc = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc,\n    procedure = require(\"./procedure.json\");\n\nfunction compile(selector, options) {\n  var next = compileUnsafe(selector, options);\n  return wrap(next);\n}\n\nfunction wrap(next) {\n  return function base(elem) {\n    return isTag(elem) && next(elem);\n  };\n}\n\nfunction compileUnsafe(selector, options) {\n  var token = parse(selector, options);\n  return compileToken(token, options);\n}\n\nfunction compileToken(token, options) {\n  token.forEach(sortRules);\n\n  if (options && options.context) {\n    var ctx = options.context;\n    token.forEach(function (t) {\n      if (!isTraversal(t[0])) {\n        t.unshift({\n          type: \"descendant\"\n        });\n      }\n    });\n    var context = Array.isArray(ctx) ? function (elem) {\n      return ctx.indexOf(elem) >= 0;\n    } : function (elem) {\n      return ctx === elem;\n    };\n\n    if (options.rootFunc) {\n      var root = options.rootFunc;\n\n      options.rootFunc = function (elem) {\n        return context(elem) && root(elem);\n      };\n    } else {\n      options.rootFunc = context;\n    }\n  }\n\n  return token.map(compileRules, options).reduce(reduceRules, falseFunc);\n}\n\nfunction isTraversal(t) {\n  return procedure[t.type] < 0;\n}\n\nfunction compileRules(rules) {\n  if (rules.length === 0) return falseFunc;\n  var options = this;\n  return rules.reduce(function (func, rule) {\n    if (func === falseFunc) return func;\n    return Rules[rule.type](func, rule, options);\n  }, options && options.rootFunc || trueFunc);\n}\n\nfunction reduceRules(a, b) {\n  if (b === falseFunc || a === trueFunc) {\n    return a;\n  }\n\n  if (a === falseFunc || b === trueFunc) {\n    return b;\n  }\n\n  return function combine(elem) {\n    return a(elem) || b(elem);\n  };\n} //:not, :has and :matches have to compile selectors\n//doing this in lib/pseudos.js would lead to circular dependencies,\n//so we add them here\n\n\nvar Pseudos = require(\"./pseudos.js\"),\n    filters = Pseudos.filters,\n    existsOne = DomUtils.existsOne,\n    isTag = DomUtils.isTag,\n    getChildren = DomUtils.getChildren;\n\nfunction containsTraversal(t) {\n  return t.some(isTraversal);\n}\n\nfunction stripQuotes(str) {\n  var firstChar = str.charAt(0);\n\n  if (firstChar === str.slice(-1) && (firstChar === \"'\" || firstChar === \"\\\"\")) {\n    str = str.slice(1, -1);\n  }\n\n  return str;\n}\n\nfilters.not = function (next, select, options) {\n  var func,\n      opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict)\n  };\n  select = stripQuotes(select);\n\n  if (opts.strict) {\n    var tokens = parse(select);\n\n    if (tokens.length > 1 || tokens.some(containsTraversal)) {\n      throw new SyntaxError(\"complex selectors in :not aren't allowed in strict mode\");\n    }\n\n    func = compileToken(tokens, opts);\n  } else {\n    func = compileUnsafe(select, opts);\n  }\n\n  if (func === falseFunc) return next;\n  if (func === trueFunc) return falseFunc;\n  return function (elem) {\n    return !func(elem) && next(elem);\n  };\n};\n\nfilters.has = function (next, selector, options) {\n  //TODO add a dynamic context in front of every selector with a traversal\n  //:has will never be reached with options.strict == true\n  var opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict)\n  };\n  var func = compileUnsafe(selector, opts);\n  if (func === falseFunc) return falseFunc;\n  if (func === trueFunc) return function (elem) {\n    return getChildren(elem).some(isTag) && next(elem);\n  };\n  func = wrap(func);\n  return function has(elem) {\n    return next(elem) && existsOne(func, getChildren(elem));\n  };\n};\n\nfilters.matches = function (next, selector, options) {\n  var opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict),\n    rootFunc: next\n  };\n  selector = stripQuotes(selector);\n  return compileUnsafe(selector, opts);\n};","map":{"version":3,"sources":["/Users/william/Dev/quicksilver/src/client/node_modules/cheerio/node_modules/css-select/lib/compile.js"],"names":["module","exports","compile","compileUnsafe","parse","require","DomUtils","isTag","Rules","sortRules","BaseFuncs","trueFunc","falseFunc","procedure","selector","options","next","wrap","base","elem","token","compileToken","forEach","context","ctx","t","isTraversal","unshift","type","Array","isArray","indexOf","rootFunc","root","map","compileRules","reduce","reduceRules","rules","length","func","rule","a","b","combine","Pseudos","filters","existsOne","getChildren","containsTraversal","some","stripQuotes","str","firstChar","charAt","slice","not","select","opts","xmlMode","strict","tokens","SyntaxError","has","matches"],"mappings":"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","sourcesContent":["/*\n\tcompiles a selector to an executable function\n*/\n\nmodule.exports = compile;\nmodule.exports.compileUnsafe = compileUnsafe;\n\nvar parse       = require(\"css-what\"),\n    DomUtils    = require(\"domutils\"),\n    isTag       = DomUtils.isTag,\n    Rules       = require(\"./general.js\"),\n    sortRules   = require(\"./sort.js\"),\n    BaseFuncs   = require(\"boolbase\"),\n    trueFunc    = BaseFuncs.trueFunc,\n    falseFunc   = BaseFuncs.falseFunc,\n    procedure   = require(\"./procedure.json\");\n\nfunction compile(selector, options){\n\tvar next = compileUnsafe(selector, options);\n\treturn wrap(next);\n}\n\nfunction wrap(next){\n\treturn function base(elem){\n\t\treturn isTag(elem) && next(elem);\n\t};\n}\n\nfunction compileUnsafe(selector, options){\n\tvar token = parse(selector, options);\n\treturn compileToken(token, options);\n}\n\nfunction compileToken(token, options){\n\ttoken.forEach(sortRules);\n\n\tif(options && options.context){\n\t\tvar ctx = options.context;\n\n\t\ttoken.forEach(function(t){\n\t\t\tif(!isTraversal(t[0])){\n\t\t\t\tt.unshift({type: \"descendant\"});\n\t\t\t}\n\t\t});\n\n\t\tvar context = Array.isArray(ctx) ?\n\t\t\tfunction(elem){\n\t\t\t\treturn ctx.indexOf(elem) >= 0;\n\t\t\t} : function(elem){\n\t\t\t\treturn ctx === elem;\n\t\t\t};\n\n\t\tif(options.rootFunc){\n\t\t\tvar root = options.rootFunc;\n\n\t\t\toptions.rootFunc = function(elem){\n\t\t\t\treturn context(elem) && root(elem);\n\t\t\t};\n\t\t} else {\n\t\t\toptions.rootFunc = context;\n\t\t}\n\t}\n\n\treturn token\n\t\t.map(compileRules, options)\n\t\t.reduce(reduceRules, falseFunc);\n}\n\nfunction isTraversal(t){\n\treturn procedure[t.type] < 0;\n}\n\nfunction compileRules(rules){\n\tif(rules.length === 0) return falseFunc;\n\n\tvar options = this;\n\n\treturn rules.reduce(function(func, rule){\n\t\tif(func === falseFunc) return func;\n\t\treturn Rules[rule.type](func, rule, options);\n\t}, options && options.rootFunc || trueFunc);\n}\n\nfunction reduceRules(a, b){\n\tif(b === falseFunc || a === trueFunc){\n\t\treturn a;\n\t}\n\tif(a === falseFunc || b === trueFunc){\n\t\treturn b;\n\t}\n\n\treturn function combine(elem){\n\t\treturn a(elem) || b(elem);\n\t};\n}\n\n//:not, :has and :matches have to compile selectors\n//doing this in lib/pseudos.js would lead to circular dependencies,\n//so we add them here\n\nvar Pseudos     = require(\"./pseudos.js\"),\n    filters     = Pseudos.filters,\n    existsOne   = DomUtils.existsOne,\n    isTag       = DomUtils.isTag,\n    getChildren = DomUtils.getChildren;\n\n\nfunction containsTraversal(t){\n\treturn t.some(isTraversal);\n}\n\nfunction stripQuotes(str){\n\tvar firstChar = str.charAt(0);\n\n\tif(firstChar === str.slice(-1) && (firstChar === \"'\" || firstChar === \"\\\"\")){\n\t\tstr = str.slice(1, -1);\n\t}\n\n\treturn str;\n}\n\nfilters.not = function(next, select, options){\n\tvar func,\n\t    opts = {\n\t    \txmlMode: !!(options && options.xmlMode),\n\t    \tstrict: !!(options && options.strict)\n\t    };\n\n\tselect = stripQuotes(select);\n\n\tif(opts.strict){\n\t\tvar tokens = parse(select);\n\t\tif(tokens.length > 1 || tokens.some(containsTraversal)){\n\t\t\tthrow new SyntaxError(\"complex selectors in :not aren't allowed in strict mode\");\n\t\t}\n\n\t\tfunc = compileToken(tokens, opts);\n\t} else {\n\t\tfunc = compileUnsafe(select, opts);\n\t}\n\n\tif(func === falseFunc) return next;\n\tif(func === trueFunc)  return falseFunc;\n\n\treturn function(elem){\n\t\treturn !func(elem) && next(elem);\n\t};\n};\n\nfilters.has = function(next, selector, options){\n\t//TODO add a dynamic context in front of every selector with a traversal\n\t//:has will never be reached with options.strict == true\n\tvar opts = {\n\t\txmlMode: !!(options && options.xmlMode),\n\t\tstrict: !!(options && options.strict)\n\t};\n\tvar func = compileUnsafe(selector, opts);\n\n\tif(func === falseFunc) return falseFunc;\n\tif(func === trueFunc)  return function(elem){\n\t\t\treturn getChildren(elem).some(isTag) && next(elem);\n\t\t};\n\n\tfunc = wrap(func);\n\n\treturn function has(elem){\n\t\treturn next(elem) && existsOne(func, getChildren(elem));\n\t};\n};\n\nfilters.matches = function(next, selector, options){\n\tvar opts = {\n\t\txmlMode: !!(options && options.xmlMode),\n\t\tstrict: !!(options && options.strict),\n\t\trootFunc: next\n\t};\n\n\tselector = stripQuotes(selector);\n\n\treturn compileUnsafe(selector, opts);\n};\n"]},"metadata":{},"sourceType":"script"}